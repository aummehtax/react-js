# useCallback Hook - Complete Notes

## What is useCallback?
- A React hook that **memoizes/remembers a function**
- Prevents function from being recreated on every render
- Returns the same function reference until dependencies change
- Used for **performance optimization**

## Why is useCallback needed?

### The Problem:
- Functions are recreated on every component render
- Child components receive "new" function props every time
- This causes unnecessary re-renders of child components
- Performance impact, especially with expensive child components

### The Solution:
- `useCallback` keeps the same function reference
- Child components don't re-render if function hasn't actually changed
- Works best when combined with `React.memo`

## Syntax:
```javascript
const memoizedFunction = useCallback(() => {
  // function logic
}, [dependencies]);
```

## Code Example Analysis:

### WITHOUT useCallback (Problem):
```javascript
const App = () => {
  const [count, setCount] = useState(0);

  // ❌ New function created every render
  const sayHi = () => {
    console.log("Hi");
  };

  return (
    <div>
      <Child sayHi={sayHi} />  {/* Child gets "new" prop every time */}
      <button onClick={() => setCount(count + 1)}>Increment {count}</button>
    </div>
  );
};

const Child = memo(({ sayHi }) => {
  console.log("child rendered"); // ❌ Logs every time count changes
  return (
    <div>
      <button onClick={sayHi}>say hi</button>
    </div>
  );
});
```

**Result:** Child re-renders every time count changes (unnecessary!)

### WITH useCallback (Solution):
```javascript
const App = () => {
  const [count, setCount] = useState(0);

  // ✅ Same function reference maintained
  const sayHi = useCallback(() => {
    console.log("Hi");
  }, []); // Empty deps = never recreate

  return (
    <div>
      <Child sayHi={sayHi} />  {/* Child gets same prop reference */}
      <button onClick={() => setCount(count + 1)}>Increment {count}</button>
    </div>
  );
};

const Child = memo(({ sayHi }) => {
  console.log("child rendered"); // ✅ Only logs when sayHi actually changes
  return (
    <div>
      <button onClick={sayHi}>say hi</button>
    </div>
  );
});
```

**Result:** Child doesn't re-render when count changes!

## When to use useCallback:

### ✅ DO use when:
- Passing functions as props to child components
- Child components are wrapped with `React.memo`
- Functions are dependencies in other hooks (`useEffect`, `useMemo`)
- Working with expensive child components
- Functions depend on props/state that don't change often

### ❌ DON'T use when:
- Function is only used within the same component
- Child components aren't memoized
- Dependencies change frequently (defeats the purpose)
- Simple, lightweight functions

## Key Points:
- **useCallback** = memoizes functions
- **React.memo** = memoizes components
- They work together for optimal performance
- Empty dependency array `[]` = never recreate function
- Dependencies in array = recreate only when those values change

## Common Pattern:
```javascript
// Parent component
const handleClick = useCallback((id) => {
  // handle click logic
}, []);

// Child component (memoized)
const Button = memo(({ onClick, children }) => {
  return <button onClick={onClick}>{children}</button>;
});
```

## Mental Model:
Think of useCallback as a "memory" for functions - it remembers the function so React doesn't have to create a new one every time, just like how you'd reuse the same recipe card instead of writing a new one each time you cook.